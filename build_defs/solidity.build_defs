"""Solidity build rules for Please.

This plugin provides rules for compiling Solidity smart contracts using Foundry's forge.
"""


def svm(
        name: str,
        version: str,
        os: str = None,
        arch: str = None,
        hashes: list = [],
        visibility: list = [],
):
    """Downloads pre-built svm binary for managing solc versions.

    svm (Solidity Version Manager) is a tool for installing and managing
    multiple versions of the Solidity compiler.

    Args:
        name: Name of the rule.
        version: svm-rs release version (e.g., "0.5.22").
        os: Target OS. Defaults to current OS.
        arch: Target architecture. Defaults to current arch.
        hashes: Optional SHA256 hashes to verify download.
        visibility: Visibility declaration.

    Example:
        svm(name = "svm", version = "0.5.22", visibility = ["PUBLIC"])
        # Access via: //third_party/solidity:svm
    """
    if not os:
        if CONFIG.OS == 'linux':
            os = 'linux'
        elif CONFIG.OS == 'darwin':
            os = 'darwin'
        else:
            fail(f'Unknown OS {CONFIG.OS}')

    if not arch:
        if CONFIG.ARCH == 'amd64':
            arch = 'amd64'
        elif CONFIG.ARCH == 'arm64':
            arch = 'arm64'
        else:
            fail(f'Unknown architecture {CONFIG.ARCH}')

    # Map to svm-rs platform naming (os_arch -> platform)
    platform_map = {
        'darwin_arm64': 'aarch64-apple-darwin',
        'darwin_amd64': 'x86_64-apple-darwin',
        'linux_arm64': 'aarch64-unknown-linux-gnu',
        'linux_amd64': 'x86_64-unknown-linux-gnu',
    }
    platform_key = f'{os}_{arch}'
    platform = platform_map.get(platform_key)
    if not platform:
        fail(f'Unsupported platform: {platform_key}')

    url = f"https://github.com/alloy-rs/svm-rs/releases/download/v{version}/svm-rs-{platform}.tar.gz"

    download = remote_file(
        name = f"_{name}#download",
        url = url,
        hashes = hashes,
    )

    return build_rule(
        name = name,
        srcs = [download],
        outs = ["svm"],
        cmd = f"tar -xzf $SRC && mv svm-rs-{platform}/svm $OUT",
        binary = True,
        visibility = visibility,
        building_description = f"Extracting svm v{version} for {platform}...",
    )


def solc(
        name: str,
        version: str,
        visibility: list = [],
):
    """Downloads a specific solc version using svm.

    This rule uses svm to download and install a specific version of the
    Solidity compiler. Configure SvmTool in .plzconfig to point to the svm binary.

    Args:
        name: Name of the rule.
        version: Solidity version to download (e.g., "0.8.20").
        visibility: Visibility declaration.

    Example:
        # .plzconfig
        [Plugin "solidity"]
        SvmTool = //third_party/solidity:svm

        # BUILD
        solc(name = "solc_0.8.20", version = "0.8.20")
    """
    svm = CONFIG.SOLIDITY.SVM_TOOL
    if not svm:
        fail("solc() requires SvmTool config option in .plzconfig")

    quoted_version = _shell_quote(version)

    return genrule(
        name = name,
        tools = {"svm": svm},
        outs = ["solc"],
        # svm install downloads to ~/.svm/version/solc-version
        # We copy it to make it portable
        cmd = f"""
            export SVM_HOME=$TMP_DIR/.svm
            $TOOLS_SVM install {quoted_version}
            cp $SVM_HOME/{version}/solc-{version} $OUT
            chmod +x $OUT
        """,
        binary = True,
        sandbox = False,  # Needs network to download solc
        visibility = visibility,
        building_description = f"Downloading solc {version}...",
    )


def solc_versions(
        versions: list,
        visibility: list = ["PUBLIC"],
):
    """Creates shared solc rules for multiple versions.

    This is a convenience function to pre-download and cache multiple solc versions.
    Use this in your third_party/solidity BUILD file to avoid repeated downloads.

    Args:
        versions: List of Solidity versions to download (e.g., ["0.8.20", "0.8.21"]).
        visibility: Visibility for all created rules.

    Example:
        # third_party/solidity/BUILD
        subinclude("//build_defs:solidity")

        solc_versions(
            versions = ["0.8.20", "0.8.21", "0.8.23"],
        )

        # Creates targets:
        # //third_party/solidity:solc_0_8_20
        # //third_party/solidity:solc_0_8_21
        # //third_party/solidity:solc_0_8_23

        # Then in .plzconfig:
        # [Plugin "solidity"]
        # SolcTool = //third_party/solidity:solc_0_8_20

    Returns:
        List of created rule names.
    """
    rules = []
    for version in versions:
        # Convert version to valid rule name (e.g., "0.8.20" -> "solc_0_8_20")
        name = "solc_" + version.replace(".", "_")
        solc(
            name = name,
            version = version,
            visibility = visibility,
        )
        rules.append(name)
    return rules


def solc_default(version: str):
    """Returns the target for a shared solc version.

    Use this to reference a pre-cached solc version in build rules.

    Args:
        version: Solidity version (e.g., "0.8.20").

    Returns:
        Target string (e.g., "//third_party/solidity:solc_0_8_20").

    Example:
        # In .plzconfig
        [Plugin "solidity"]
        SolcTool = %(call solc_default 0.8.20)
    """
    name = "solc_" + version.replace(".", "_")
    return f"//third_party/solidity:{name}"


def sol_library(
        name: str,
        src: str,
        deps: list = [],
        test_only: bool = False,
        plugins: dict = {},
        visibility: list = [],
):
    """Creates a Solidity library that can be used as a dependency.

    This rule creates a filegroup that provides sol_srcs for downstream rules.
    It's the basic building block for Solidity dependency management.

    Args:
        name: Name of the rule.
        src: Solidity source file.
        deps: Dependencies (other sol_library or sol_contract rules).
        test_only: If True, only available to test rules.
        plugins: Additional providers to add (e.g., sol_artifacts, go).
        visibility: Visibility specification.

    Returns:
        A filegroup rule that provides sol_srcs.
    """
    solidity_rule = filegroup(
        name = f'_{name}#solidity',
        srcs = [src],
        visibility = visibility,
        exported_deps = deps,
        requires = ['sol_srcs'],
        output_is_complete = False,
        test_only = test_only,
    )
    provides = {'sol_srcs': solidity_rule}

    for lang, rule in plugins.items():
        provides[lang] = rule

    return filegroup(
        name = name,
        srcs = [src],
        deps = provides.values(),
        provides = provides,
        visibility = visibility,
        output_is_complete = False,
        test_only = test_only,
    )


def sol_contract(
        name: str,
        src: str,
        deps: list = [],
        solc_version: str = None,
        solc_flags: str = '',
        contract_names: list = [],
        skip: list = [],
        languages: list = None,
        test_only: bool = False,
        visibility: list = [],
        _is_dir: bool = False,
):
    """Compiles a Solidity contract using Forge.

    This is the main compilation rule. It uses Foundry's forge to compile
    Solidity contracts, extracts ABIs and bytecode, and optionally generates
    language bindings (currently Go via abigen).

    If SolcTool is configured in .plzconfig, uses the local solc binary.
    Otherwise, uses forge's --use flag to download via svm.

    Args:
        name: Name of the rule.
        src: Solidity source file or directory.
        deps: Dependencies (other sol_library or sol_contract rules).
        solc_version: Solidity compiler version (e.g., "0.8.20"). Used when
            downloading via svm. Defaults to DefaultSolcVersion config.
        solc_flags: Additional flags for solc/forge.
        contract_names: Names of contracts in the source file. Required for
            multi-contract files when generating language bindings.
        skip: Contract names to skip during compilation.
        languages: Output languages (e.g., ['go'] for Go bindings). Defaults to
            the plugin's default_languages config.
        test_only: If True, only available to test rules.
        visibility: Visibility specification.

    Returns:
        sol_library rule that provides:
        - sol_srcs: Solidity source files
        - sol_artifacts: Compiled ABI and bytecode
        - go: Go bindings (if 'go' in languages and abigen_tool configured)
    """
    # Apply defaults from config
    if solc_version is None:
        solc_version = CONFIG.SOLIDITY.DEFAULT_SOLC_VERSION
    if languages is None:
        # Default to no language bindings when contract_names isn't specified.
        # This prevents "found packages X and Y" Go errors when a source file has
        # multiple contracts/interfaces that would each get their own package.
        # Users must explicitly request languages=['go'] AND provide contract_names.
        if contract_names:
            languages = CONFIG.SOLIDITY.DEFAULT_LANGUAGES or ['go']
        else:
            languages = []

    # Extract interface and contract names from source
    file_to_cat = '$SRCS'
    cmd = ' && '.join([
        f"cat {file_to_cat} | sed -n 's#.*interface \(.*\) {{#\\1#gp' | sed -e 's/\\s.*$//' > $OUTS",
        f"cat {file_to_cat} | sed -n 's#.*contract \(.*\) {{#\\1#gp' | sed -e 's/\\s.*$//' >> $OUTS",
        f"path={file_to_cat} && echo $path && base=$(basename $path)",
        'sed -i -e "s/^/$base\\//" $OUTS',
    ])
    if _is_dir:
        singleton_cmd = ' && '.join([
            f"cat $file | sed -n 's#.*interface \(.*\) {{#\\1#gp' | sed -e 's/\\s.*$//' > tmp",
            f"cat $file | sed -n 's#.*contract \(.*\) {{#\\1#gp' | sed -e 's/\\s.*$//' >> tmp",
            f"path=$file && echo $path && base=$(basename $path)",
            'sed -i -e "s/^/$base\\//" tmp',
            "cat tmp >> $OUTS && cat $OUTS",
        ])
        file_to_cat = '$(find $SRCS -type f -printf "%T@ %p\\n" | sort -nr | cut -d\\  -f2-) '
        cmd = f"touch $OUTS && for file in {file_to_cat}; do {singleton_cmd}; done"

    interfaces_rule = genrule(
        name = f"{name}_interfaces",
        srcs = [src],
        out = f"{name}.interfaces",
        cmd = cmd,
        test_only = test_only,
    )

    # Build skip flags for contracts to exclude (SECURITY: quote each item)
    skip_cmd = ""
    for skipped in skip:
        quoted_skip = _shell_quote(skipped)
        skip_cmd += f" --skip {quoted_skip} "

    # Configure forge flags from config
    optimize = CONFIG.SOLIDITY.OPTIMIZE
    optimizer_runs = CONFIG.SOLIDITY.OPTIMIZER_RUNS or 100
    forge_flags = ""
    if optimize:
        forge_flags = f"--optimize --optimizer-runs {optimizer_runs}"

    # Add EVM version for newer solc versions
    if _compare_version_lists(_version_tuple(solc_version), _version_tuple("0.8.20")):
        forge_flags += " --evm-version paris"

    # SECURITY: Quote solc_flags to prevent injection
    all_flags = forge_flags
    if solc_flags:
        quoted_solc_flags = _shell_quote(solc_flags)
        all_flags += " " + quoted_solc_flags

    # Build the forge command using shared helpers
    # Copy main source and any dep .sol files from the same package to src/
    # This enables relative imports like "./Counter.sol" to work
    pkg = package_name()
    setup_cmd = f'mkdir -p src && ([ -d "$SRCS" ] && cp -r "$SRCS"/* src/ 2>/dev/null || cp "$SRCS" src/ 2>/dev/null) && (find {pkg} -maxdepth 1 -name "*.sol" -exec cp {{}} src/ \\; 2>/dev/null || true)'
    solc_use_arg = _get_solc_use_arg(solc_version)
    solc_cmd = f'build --use {solc_use_arg} {skip_cmd} {all_flags} --extra-output bin --extra-output-files bin --root .'

    # Extract ABIs and bytecode from JSON files
    abi_bin_extract = 'if [ -d out ]; then for json_file in $(find out -name "*.json" -type f 2>/dev/null); do jq ".abi" "$json_file" > "${json_file%.json}.abi" 2>/dev/null || true; jq -r ".bytecode.object // .bytecode" "$json_file" | sed "s/^0x//" > "${json_file%.json}.bin" 2>/dev/null || true; done; fi'

    # Use shared helpers for tools and remappings
    build_tools = _get_forge_tools()
    collect_remappings = _collect_remappings_cmd()

    forge_build = genrule(
        name = f"_{name}#forge_build",
        srcs = [src],
        deps = deps,
        requires = ['sol_srcs', 'sol_remappings'],
        tools = build_tools,
        out = f"{name}_out",
        needs_transitive_deps = True,
        output_is_complete = True,
        sandbox = CONFIG.SOLIDITY.SANDBOX,
        cmd = f'{collect_remappings} && {setup_cmd} && $TOOLS_FORGE {solc_cmd} $REMAPPINGS || [ -d out ] && {abi_bin_extract} && mkdir -p $OUT && ([ -d out ] && mv out/* $OUT || mkdir -p $OUT)',
        test_only = test_only,
    )
    plugins = {'sol_artifacts': forge_build}

    # Generate Go bindings if requested and abigen is configured
    abigen_tool = CONFIG.SOLIDITY.ABIGEN_TOOL
    go_ethereum_dep = CONFIG.SOLIDITY.GO_ETHEREUM_DEP

    if 'go' in languages and abigen_tool:
        go_srcs = genrule(
            name = f"_{name}#gosrcs",
            srcs = {
                "forge_build": forge_build,
                "interfaces": interfaces_rule,
            },
            tools = [abigen_tool],
            output_dirs = ["out/**"],
            cmd = ' && '.join([
                'mkdir out',
                f'while read p; do $TOOL --type=instance --abi=$SRCS_FORGE_BUILD/"$p".abi --bin=$SRCS_FORGE_BUILD/"$p".bin --pkg=$(basename "${{p,,}}") --out=out/"$(basename ${{p,,}})".go; done < $SRCS_INTERFACES',
            ]),
            needs_transitive_deps = True,
            visibility = visibility,
            test_only = test_only,
        )

        # Build Go libraries for each contract
        exported_deps = []
        go_deps = [go_ethereum_dep] if go_ethereum_dep else []

        if len(contract_names) == 0:
            import_path = package_name() + "/" + name.replace("_", "")
            go = go_library(
                name = f'_{name}#golib',
                srcs = [go_srcs],
                deps = go_deps,
                test_only = test_only,
                import_path = import_path,
                visibility = visibility,
            )
            exported_deps.append(go)

        pkg = package_name()
        for contract_name in contract_names:
            contract_name_lower = contract_name.lower()
            # SECURITY: Quote contract_name in shell command
            quoted_contract = _shell_quote(contract_name_lower)
            quoted_pkg = _shell_quote(pkg)
            contract_go_srcs = genrule(
                name = f"_{name}_{contract_name_lower}#gosrcs",
                srcs = [go_srcs],
                out = f'{contract_name_lower}.go',
                cmd = f'mv $PKG_DIR/{quoted_contract}.go . && echo {quoted_pkg}',
            )
            import_path = package_name() + "/" + contract_name_lower
            go = go_library(
                name = f"_{name}_{contract_name_lower}#golib",
                srcs = [contract_go_srcs],
                deps = go_deps,
                test_only = test_only,
                import_path = import_path,
                visibility = visibility,
            )
            exported_deps.append(go)

        golibs = filegroup(
            name = f"_{name}#golibs",
            exported_deps = exported_deps,
        )
        plugins['go'] = golibs

    # Return sol_library with all plugins
    return sol_library(
        name = name,
        src = src,
        deps = deps,
        test_only = test_only,
        plugins = plugins,
        visibility = visibility,
    )


def sol_get(
        name: str,
        repo: str,
        revision: str,
        hashes: list = [],
        deps: list = [],
        import_prefix: str = "",
        solc_version: str = None,
        package: str = '.',
        install: list = ['.'],
        solc_flags: str = '',
        contract_names: list = [],
        skip: list = [],
        languages: list = None,
        test_only: bool = False,
        visibility: list = [],
):
    """Downloads a Solidity library from GitHub and compiles it.

    This rule downloads Solidity source code from a GitHub repository
    and compiles it using sol_contract. Import remappings are automatically
    generated based on the import_prefix.

    Args:
        name: Name of the rule.
        repo: GitHub repo in 'org/repo' format (e.g., 'OpenZeppelin/openzeppelin-contracts').
        revision: Git revision (commit SHA, tag, or branch).
        hashes: SHA256 hashes for download verification. Format: ["sha256:abc123..."]
            Strongly recommended - verifies the download hasn't been tampered with.
        deps: Dependencies (other sol_library or sol_contract rules).
        import_prefix: Import path prefix for this library. Defaults to "{name}/".
            Example: "@openzeppelin/contracts/" allows imports like
            `import "@openzeppelin/contracts/token/ERC20/ERC20.sol";`
        solc_version: Solidity compiler version. Defaults to plugin config.
        package: Subdirectory within the repo containing sources.
        install: List of subdirectories to install from the package.
        solc_flags: Additional solc flags.
        contract_names: Contract names for language binding generation.
        skip: Contracts to skip during compilation.
        languages: Output languages. Defaults to plugin config.
        test_only: If True, only available to test rules.
        visibility: Visibility specification.
    """
    # SECURITY: Validate no path traversal
    _validate_no_traversal(package, "package")
    for install_path in install:
        _validate_no_traversal(install_path, "install")

    org, _, repo_name = repo.partition('/')

    # SECURITY: Log warning if no hash verification
    if not hashes:
        log.warning(f"sol_get('{name}'): No hash verification. Consider adding hashes=['sha256:...'] for supply chain security.")

    zip_file = remote_file(
        name = f"_{name}#zip",
        url = f'https://github.com/{org}/{repo_name}/archive/{revision}.zip',
        hashes = hashes,
    )

    # SECURITY: Quote all path components
    # GitHub strips 'v' prefix from version tags in archive directory names
    # e.g., v1.9.4 becomes forge-std-1.9.4/ not forge-std-v1.9.4/
    archive_revision = revision.lstrip('v') if revision.startswith('v') else revision
    quoted_archive_revision = _shell_quote(archive_revision)
    quoted_repo_name = _shell_quote(repo_name)

    # GitHub archives use {repo_name}-{version} as the directory name
    archive_dir = f'{quoted_repo_name}-{quoted_archive_revision}'
    cmds = [f'$TOOL x $SRCS -o tmp && mkdir $OUTS']
    for install_path in install:
        quoted_install = _shell_quote(install_path)
        quoted_package = _shell_quote(package)

        if install_path == ".":
            # Copy entire package contents preserving structure
            cmds.append(f'cp -r tmp/{archive_dir}/{quoted_package}/* $OUTS/')
        else:
            # Copy specific subdirectory
            cmds.append(f'mkdir -p $OUTS/{quoted_install}')
            cmds.append(f'cp -r tmp/{archive_dir}/{quoted_package}/{quoted_install}/* $OUTS/{quoted_install}/')
        # Remove test files
        cmds.append(f'find $OUTS -name "*.t.sol" -delete 2>/dev/null || true')

    extract_rule = build_rule(
        name = f"_{name}#extract",
        srcs = [zip_file],
        tools = [CONFIG.JARCAT_TOOL],
        cmd = "&&".join(cmds),
        outs = [name],
        visibility = visibility,
    )

    # Create remapping file: import_prefix=package/name/
    # This tells forge to resolve imports like "@openzeppelin/contracts/X" to "third_party/openzeppelin-contracts/X"
    # The package path prefix is needed because Please organizes dep files by package
    pkg = package_name()
    quoted_package = _shell_quote(package)
    quoted_name = _shell_quote(name)
    quoted_pkg = _shell_quote(pkg)

    if import_prefix:
        # Explicit import_prefix provided
        remapping_rule = genrule(
            name = f"_{name}#remapping",
            cmd = f'echo "{import_prefix}={pkg}/{name}/" > $OUT',
            outs = [f"{name}.remapping"],
            test_only = test_only,
        )
    else:
        # Auto-detect import_prefix from package.json using please_sol
        remapping_rule = genrule(
            name = f"_{name}#remapping",
            srcs = [zip_file],
            tools = {"plzsol": CONFIG.SOLIDITY.PLEASE_SOL_TOOL},
            cmd = f'$TOOLS_PLZSOL detect-prefix --zip=$SRCS --package={quoted_package} --name={quoted_name} --out_dir={quoted_pkg} > $OUT',
            outs = [f"{name}.remapping"],
            test_only = test_only,
        )

    # Create sol_library with remapping provider
    _sol_get_library(
        name = name,
        src = extract_rule,
        remapping = remapping_rule,
        deps = deps,
        solc_version = solc_version,
        solc_flags = solc_flags,
        contract_names = contract_names,
        skip = skip,
        languages = languages,
        test_only = test_only,
        visibility = visibility,
    )


def _sol_get_library(
        name: str,
        src,
        remapping,
        deps: list = [],
        solc_version: str = None,
        solc_flags: str = '',
        contract_names: list = [],
        skip: list = [],
        languages: list = None,
        test_only: bool = False,
        visibility: list = [],
):
    """Internal helper for sol_get that creates the library with remapping support.

    If languages are specified, this will also compile the contracts and generate
    language bindings (e.g., Go bindings via abigen).
    """
    # Apply defaults from config
    if solc_version is None:
        solc_version = CONFIG.SOLIDITY.DEFAULT_SOLC_VERSION
    if languages is None:
        # Default to no language bindings when contract_names isn't specified.
        # This prevents "found packages X and Y" Go errors when a library has
        # multiple contracts/interfaces that would each get their own package.
        # Users must explicitly request languages=['go'] AND provide contract_names.
        if contract_names:
            languages = CONFIG.SOLIDITY.DEFAULT_LANGUAGES or ['go']
        else:
            languages = []

    # Create the solidity source filegroup
    solidity_rule = filegroup(
        name = f'_{name}#solidity',
        srcs = [src],
        visibility = visibility,
        exported_deps = deps,
        requires = ['sol_srcs'],
        output_is_complete = False,
        test_only = test_only,
    )

    # Create remapping filegroup that collects all remappings from deps
    remapping_fg = filegroup(
        name = f'_{name}#remappings',
        srcs = [remapping],
        visibility = visibility,
        exported_deps = deps,
        requires = ['sol_remappings'],
        output_is_complete = False,
        test_only = test_only,
    )

    provides = {
        'sol_srcs': solidity_rule,
        'sol_remappings': remapping_fg,
    }

    # Compile and generate bindings if requested
    if languages or contract_names:
        contract_deps = deps + [remapping_fg]
        contract = sol_contract(
            name = f'_{name}#contract',
            src = src,
            deps = contract_deps,
            solc_version = solc_version,
            solc_flags = solc_flags,
            contract_names = contract_names,
            skip = skip,
            languages = languages,
            test_only = test_only,
            visibility = visibility,
            _is_dir = True,
        )
        for lang in languages:
            provides[lang] = f':_{name}#contract'

    all_deps = [solidity_rule, remapping_fg]
    if languages or contract_names:
        all_deps.append(f':_{name}#contract')

    return filegroup(
        name = name,
        srcs = [src],
        deps = all_deps,
        provides = provides,
        visibility = visibility,
        output_is_complete = False,
        test_only = test_only,
    )


def sol_test(
        name: str,
        src: str,
        deps: list = [],
        solc_version: str = None,
        solc_flags: str = '',
        visibility: list = [],
        timeout: int = 0,
        labels: list = [],
):
    """Runs Solidity tests using Forge.

    This rule compiles the test contract and runs it using Foundry's forge test.

    Args:
        name: Name of the rule.
        src: Test source file (typically *.t.sol).
        deps: Dependencies (other sol_library or sol_contract rules).
        solc_version: Solidity compiler version. Defaults to plugin config.
        solc_flags: Additional solc flags.
        visibility: Visibility specification.
        timeout: Test timeout in seconds.
        labels: Additional labels for the test.
    """
    if solc_version is None:
        solc_version = CONFIG.SOLIDITY.DEFAULT_SOLC_VERSION

    contract = sol_contract(
        name = f"_{name}#contract",
        src = src,
        deps = deps,
        solc_version = solc_version,
        solc_flags = solc_flags,
        languages = [],
        visibility = visibility,
    )

    # Gather solidity source files from contract and its deps
    sol_src_data = genrule(
        name = f'_{name}#solsrcs',
        srcs = [contract],
        deps = deps,  # Include test deps so their sol_srcs are collected
        needs_transitive_deps = True,
        output_is_complete = True,
        requires = ['sol_srcs'],
        out = f"{name}_solsrcdata",
        cmd = "mkdir -p $OUT && mv * $OUT 2>/dev/null || true",
        visibility = visibility,
    )
    # Get the package directory (e.g., "test" from "//test:_counter_test#solsrcs")
    canonical_path = canonicalise(sol_src_data).removeprefix('//')
    pkg_path = canonical_path.split(':')[0]
    data_package_root_dir = pkg_path.split('/')[0]

    # Gather the test's solidity compilation artifacts
    sol_artifacts_data = genrule(
        name = f'_{name}#solartifacts',
        srcs = [contract],
        requires = ['sol_artifacts'],
        out = f"{name}_solartifactdata",
        cmd = "mkdir -p $OUT && mv $SRCS/* $OUT",
        visibility = visibility,
    )

    # Gather remappings from deps
    sol_remapping_data = genrule(
        name = f'_{name}#remappings',
        srcs = [contract],
        deps = deps,
        needs_transitive_deps = True,
        requires = ['sol_remappings'],
        out = f"{name}_remappings",
        cmd = 'mkdir -p $OUT && find . -name "*.remapping" -exec cp {} $OUT/ \\; 2>/dev/null || true',
        visibility = visibility,
    )

    # Build test command using shared helpers
    quoted_data_dir = _shell_quote(data_package_root_dir)
    collect_remappings = _collect_remappings_cmd(f"$(location {sol_remapping_data})")
    solc_use_arg = _get_solc_use_arg(solc_version)

    base_cmds = [
        collect_remappings,
        f"mv $(location {sol_src_data}) src",
        f"mv $(location {sol_artifacts_data}) out",
        f"rm -r {quoted_data_dir} 2>/dev/null || true",
        "mv src/* . && rmdir src",
    ]

    test_tools = _get_forge_tools()
    test_cmd = '&&'.join(base_cmds + [
        f"$TOOLS_FORGE test --root . --use {solc_use_arg} -vv $REMAPPINGS $TEST_ARGS",
    ])

    return gentest(
        name = name,
        data = [sol_src_data, sol_artifacts_data, sol_remapping_data],
        sandbox = CONFIG.SOLIDITY.SANDBOX,
        test_tools = test_tools,
        test_cmd = test_cmd,
        no_test_output = True,
        timeout = timeout,
        labels = labels,
        visibility = visibility,
    )


def _shell_quote(s: str) -> str:
    if not s:
        return "''"
    return "'" + s.replace("'", "'\\''") + "'"


def _validate_no_traversal(path: str, param_name: str):
    if '..' in path:
        fail(f"{param_name} cannot contain '..': {path}")


def _version_tuple(v):
    return [int(p) for p in v.split(".")]


def _compare_version_lists(a, b):
    for i in range(len(a)):
        if a[i] > b[i]:
            return True
        if b[i] > a[i]:
            return False
    return True


def _get_forge_tools(include_solc: bool = True) -> dict:
    """Returns tools dict with forge and optionally solc.

    Args:
        include_solc: If True and local solc is configured, include it.

    Returns:
        Dict suitable for tools parameter of genrule/gentest.
    """
    tools = {"forge": CONFIG.SOLIDITY.FORGE_TOOL}
    local_solc = CONFIG.SOLIDITY.SOLC_TOOL
    if include_solc and local_solc:
        tools["solc"] = local_solc
    return tools


def _get_solc_use_arg(solc_version: str) -> str:
    """Returns the --use argument for forge.

    If local solc is configured, returns $TOOLS_SOLC.
    Otherwise returns the quoted version string.

    Args:
        solc_version: Solidity version (e.g., "0.8.20").

    Returns:
        String suitable for --use flag.
    """
    local_solc = CONFIG.SOLIDITY.SOLC_TOOL
    if local_solc:
        return "$TOOLS_SOLC"
    return _shell_quote(solc_version)


def _collect_remappings_cmd(search_path: str = ".") -> str:
    """Returns bash command to collect remappings into $REMAPPINGS variable.

    Args:
        search_path: Path to search for .remapping files.

    Returns:
        Bash command that sets $REMAPPINGS.
    """
    return f'REMAPPINGS=""; for f in $(find {search_path} -name "*.remapping" 2>/dev/null); do while read line; do REMAPPINGS="$REMAPPINGS --remappings $line"; done < "$f"; done'
